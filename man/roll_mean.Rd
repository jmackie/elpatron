% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roll_mean.R
\name{roll_mean}
\alias{roll_mean}
\title{Efficient rolling mean}
\usage{
roll_mean(x, window, na.rm = TRUE, ema = FALSE)
}
\arguments{
\item{x}{numeric vector to be rolled over.}

\item{window}{integer; the window size in \emph{vector element} units. This
argument is silently truncated.}

\item{na.rm}{logical; should NAs be discarded?}

\item{ema}{logical; return an "\strong{e}xponentially weighted
\strong{m}oving \strong{a}verage"?}
}
\value{
A vector of the same length as \code{x}.
}
\description{
Generate a (right-aligned) rolling mean for a vector, optionally
  applying exponential weights.
}
\details{
This function rolls over \code{x} by "element", i.e. \code{window =
  10} will average over 10 \emph{adjacent} values in \code{x}. This is
  emphasised as often a time-windowed rolling average is desired. The latter
  can only be achieved if data are sampled uniformly, i.e. a \code{window =
  10} rolling mean will also give a 10-second moving average with data
  sampled at 1 Hz. If data are not sampled consistently, consider passing
  them through \code{\link{uniform_sampling}}.

  The rolling mean returned here is right-aligned, padded with leading zeros.
  That is, there are \code{window - 1} zeros at the start of the return
  vector.

  Note that the \code{window} argument is silently truncated
  (\code{\link[base]{trunc}}). This because a floating-point window size
  makes no sense...
}
\examples{
library(dplyr, warn.conflicts = FALSE)
data(chaingang)

# The 'chaingang' dataset is sampled at 1 Hz
# without any breaks.
diff(chaingang$time.s) \%>\% unique  # NB!

# 30 second rolling mean, and 25 second exponentially-
# weighted rolling mean.
chaingang <- mutate(chaingang,
                    power.30mean = roll_mean(power.W, 30),
                    power.25ema = roll_mean(power.W, 25, ema = TRUE))

chaingang <- chaingang[-(1:29), ]  # Remove zero padding.

plot(power.W ~ time.s, type = "l", col = "gray", data = chaingang)
lines(power.25ema ~ time.s, data = chaingang)

# FYI:
normalised_power <- mean(chaingang$power.30mean^4) ^ (1/4)
xPower <- mean(chaingang$power.25ema^4) ^ (1/4)
}
\seealso{
\code{\link{roll_mean.time}} for rolling over \emph{messily} sampled
  data.
}

