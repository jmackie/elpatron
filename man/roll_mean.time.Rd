% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roll_mean.R
\name{roll_mean.time}
\alias{roll_mean.time}
\title{Roll over time windows.}
\usage{
roll_mean.time(x, time, window, na.rm = TRUE)
}
\arguments{
\item{x}{numeric vector to be rolled over.}

\item{time}{numeric vector of sampling time values.}

\item{window}{integer; the window size in \emph{time} units.}

\item{na.rm}{logical; should NAs be discarded?}
}
\value{
A vector of the same length as \code{x}.
}
\description{
A less efficient implementation of \code{\link{roll_mean}} that
  can roll over \emph{inconsistently sampled} data by a specified time
  window.
}
\details{
In essence, this function iterates of elements in \code{x}, looking
  back through previous elements until the corresponding element in
  \code{time} exceeds the specified \code{window}. For example, if the
  iteration was at \code{x[100]}, where \code{time[100] == 60} (seconds), a
  cumulative mean would be applied to previous values of \code{x} until
  \code{time[i] == 30}, if \code{window = 30}.
}
\examples{
library(dplyr, warn.conflicts = FALSE)
data(chaingang)

# 'chaingang' is sampled uniformly at 1 Hz, but lets
# pretend it's messy...
chaingang <- sample_n(chaingang, 1500) \%>\% arrange(time.s)

diff(chaingang$time.s) \%>\% table

# With this function, we can still get a 30 second rolling
# average:
chaingang <- mutate(chaingang,
                    power.30mean = roll_mean.time(power.W, time.s, 30))

plot(power.W ~ time.s, type = "l", col = "gray", data = chaingang)
lines(power.30mean ~ time.s, data = chaingang)
}

